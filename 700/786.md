# k-th-smallest-prime-fraction

## Binary Search

如果我们能找到一个数 mid，恰好有 k 个素数分数小于 mid，那么这些分数中最大的就是我们要找的答案。

首先，对于一个 mid，我们如何找到有多少个比它小的素数分数呢？这时我们可以采用双指针。

设定指针 j 来指定分母，从左往右，每次枚举一个分母；

设定指针 i 来指定分子，从左往右移动，最小是 0 ，最大是 j−1，并且移动的过程中，还要保证 $arr[i]<\alpha * arr[j]$ 成立。

当 i 移动停止后，说明 $arr[0]\cdots arr[i]$ 都可以作为分子，即分母为 arr[j] 的小于 α 的素数分数一共有 i+1 个

在 j 向右移动的过程中，将每个 j 对应的 i+1 累加起来，就是最终的小于 mid 的素数分数的个数

在移动的时候，记录一个当前最大素数分数 $max[x,y]$

那么如何找到我们需要的 mid 呢？

如果上述过程最后的个数等于 k ，那说明选的 mid 刚刚好。

如果个数小于 mid ，那说明当前选取的 mid 过小；

如果个数大于 mid，那说明当前选取的 mid 过大。

这很明显，可以用二分查找来寻找最合适的 mid。


## code
### swift

```swift
/*
Constraints:

2 <= arr.length <= 1000
1 <= arr[i] <= 3 * 104
arr[0] == 1
arr[i] is a prime number for i > 0.
All the numbers of arr are unique and sorted in strictly increasing order.
1 <= k <= arr.length * (arr.length - 1) / 2
*/
class Solution {
  func kthSmallestPrimeFraction(_ arr: [Int], _ k: Int) -> [Int] {
    let n = arr.count
    var left = 0.0
    var right = 1.0
    while left < right {
      let mid = (left + right) / 2.0
      var count = 0
      var max = [0, 1]
      var j = 1
      for i in 0..<n {
        while j < n && Double(arr[i]) >= mid * Double(arr[j]) {
          j += 1
        }
        count += n - j
        if j < n && max[0] * arr[j] < arr[i] * max[1] {
          max = [arr[i], arr[j]]
        }
      }
      if count == k {
        return max
      } else if count < k {
        left = mid
      } else {
        right = mid
      }
    }
    return []
  }
}
```
